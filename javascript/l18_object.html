<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>js object</title>
</head>
<body>
    <h1>자바스크립트의 Object</h1>
    <h2>참조형 데이터 타입인 Object</h2>
    <ul>
        <li>함수를 new 연산자로 호출하면 객체가 생성되는데 이를 Oject라 부른다.</li>

        
        <li>Object는 모든 함수의 부모프로토타입으로, 모든 객체는 생성시 부모인 Object 프로토타입을 참조(__proto__)한다.</li>

        <li>Object에는 toStiring()과 valueOf()가 있고 객체를 콘솔에 출력할 때 (new Object() ==> new Object().value+Of()) .valueOf()가 생략된다. </li>
        <li>모든 객체의 부모인 Object 에는 생성자(constructor)와 valueOf와 같은 객체 생성시 꼭 필요한 것들이 정의되어 있다.</li>
        
        <li>함수이름() new 연산자로 호출되면 함수가 아니라 생성자(constructor)라 불리고 객체를 만들때 꼭 호출되기 때문에 생성자이다.</li>
        
        <li>함수형언어인 자바스크립트는 함수가 new 호출시 객체가 되기 때문에 이때 함수를 프로토타입이라 부른다.</li>
        <li>프로토타입은 함수가 객체가될 때 필요한 설계도로 this로 프로퍼티를 정의하고 참조한다.</li>
        <li>프로토타입인 함수에 return은 동작하지 않는다.</li>
        <li>프로토타입인 함수의 이름 대문자로 시작하고 낙타표기법을 사용한다.
            (예 new Number("10") new String("안녕") BigInt,RegExp)
        </li>
        <li>모든 객체(new)는 참조형데이터 타입으로 instanceof 로 비교한다.
            <ul>
                <li>13 instanceof Number :
                    <script>document.write(13 instanceof Number)</script>
                </li>
                <li>new Number(13) instanceof Number :
                    <script>document.write(new Number(13) instanceof Number)</script>
                </li>
                <li>new Number(13) instanceof Object :
                    <script>document.write(new Number(13) instanceof Object)</script>
                </li>
                <li>(typof 13) == "number" :
                    <script>document.write( (typeof 13) =="number")</script>
                </li>

            </ul>

        </li>
    </ul>
<script>
//함수   
function sum(){
    let a=10;
    let b=20;
    //this.toString=function(){}
    return a+b;
}
console.log(sum());
console.log(new sum().toString());
console.log(new sum().valueOf());

//this로 프로토타입을 작성하지 않았다.(객체의 프로퍼티가 없다.)

//오브젝트의 프로토타입
function SumObj(){
    this["a"]=10;
    this.b=20;
    this.sum=function(){
        return this.a+this.b;
    }
    return this.a+this.b; 
}
console.log(SumObj()); //함수 (권장하지 않음)
const sumObj=new SumObj();

console.log(sumObj); //object에서 return 사용되지 않음
console.log("sumObj.a",sumObj.a);
console.log(sumObj.sum());
//{a:10, b:20} 
//JavaScript Object Notaion(표기법)

//Object를 JSON을 이용해 리터럴하게 생성
const avgObj={
    a: 10,
    b: 20,
    getAvg:function(){return (this.a+this.b)/2}
}
console.log(avgObj);
console.log(avgObj.getAvg());
</script>    
    <h2>Object 선언법</h2>
    <ul>
        <li>function ObjectName(param){ this.param=param; this.func=function(){} }</li>
      
        <li>const ObjectName=function(){}</li> 

        <li>class ObjectName{  constructor(param){this.param=param;} func(){} }(es6)
            <ul>
                <li>class는 수거코드로 function을 class인척 꾸며놓은 것 </li>
                <li>상속(__proto__)을 편리하게 하기 위해서 존재(부모의 필드를 물려받는 것을 상속)</li>
                <li>function의 역활이 함수와 프로토타입 두개라서 분리시키기 위해 존재
                </li>
            </ul>
        </li>

    </ul>
    <h2>객체 생성법</h2>
    <ul>
        <li>new 연산자로 생성자를 호출하면 된다.</li>
        <li>new 생성자();    (생성자==함수이름,클래스이름)</li>
        <li>const objName={ a:"", b: 0, c: function(){} } (리터럴한 선언법)</li>
    </ul>
    <h2 id="objTest"
    style="color: blue; background-color: burlywood;">객체 사용법</h2>
    <ul>
        <li> 객체.property , 객체["propertyName"]       참조 </li>
        <li> 객체.property = ""   대입</li>
        <li> 객체.property()      함수실행</li>
    </ul>
<script>
const userInfo={id : "ckm" , name: "최경민" , age : 36,  family : ["엄마","아빠","누나","형"]};
console.log("userInfo.id",userInfo.id);

console.log("userInfo['id']",userInfo["id"]);
console.log("userInfo['family'][1]",userInfo["family"][1]);

console.log(objTest["id"]);
console.log(objTest["style"]["color"]);
console.log(objTest["style"]["backgroundColor"]);

</script>
</body>
</html>