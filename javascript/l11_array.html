<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>js Array</title>
</head>
<body>
    <h1>자바스크립트의 배열</h1>
    <h2>자바스크립트 배열의 작성법</h2>
    <ol>
        <li>const arr = [data,data,data...]</li>
        <li>const arr = new Array(data,data,data...)(단순성,가독성,실행속도 때문에 리터럴 방식 선호)</li>
        <li>let arr=[] (권장하지 않음)</li>
        <li>var arr=[] (권장하지 않음)</li>
        <li>const arr=[]; arr[0]=data; arr[1]=data; ....</li>
    </ol>
    <h2>배열의 규칙</h2>
    <ul>
        <li>data type은 제한이 없다. [1,"2",3.0,"사",5.3]</li>
        <li>const로 선언하기를 기대한다.
            <ul>
                <li>const로 선언하면 참조형인 배열이 다른 것을 참조하지 않기 때문이다. 예) [1,3,4][0]==> 100[0] </li>
                <li>상수인 const는 참조한 데이터를 바꿀 수 없다.</li>
                <li>상수가 참조형 데이터 타입인 객체를 참조하고 있다면
                    해당 객체는 바뀔수 없지만 객체가 참조하는 데이터는 바뀔 수 있다. ({},function,document,HTMLConllection==array,Array)
                </li>
            </ul>
        </li>
        <li>리터럴한 방식이 좋다.</li>
        <li>한 배열에 data를 통일하는 경향이 있다.</li>
        <li>typeof [1,2,3] : 
            <script>document.write(typeof [1,2,3])</script>
            (typeof는 기본데이터 타입을 제외한 모든 참조형을 Object로 출력한다.) 
        </li>
        <li>Array.isArray([1,2,3]) : 
            <script>document.write( Array.isArray([1,2,3]));</script>
        </li>
        <li>[1,2,3] instanceof Array : 
            <script>document.write([1,2,3] instanceof Array);</script>
            (instanceof는 참조형 datatype을 비교한 연산자)
        </li>
        <li>배열의 data로 배열을 참조할 수 있는데 이때 참조하는 수만큼 n차 배열이라 한다. 예) [[[1,2][1,2]][[1,2][1,2]]....]</li>
        <li>2차원 배열을 초과하는 구조를 만들어서는 안된다.</li>
    </ul>
<script>
const arr=[1,"2",3.0,"사",5.3];
arr[1]="200";
//arr=200;


const req_arr= new Array(1,"2",3.0,"사",5.3);
let let_arr=[];

//[1,2,3,4,..] == new Array(1,2,3,4,....) 같은 결과를 갖는다.
//const 를 배열 선언에 사용하는 이유!
console.log("arr",arr);
console.log("req_arr",req_arr);
console.log("arr",arr[4]);

for(let i=0; i<arr.length; i++){
    console.log(arr[i]);
}

const mul2_arr=[[1,2,3,4],[10,20,30,40],[100,200,300,400],[1000,2000,3000,4000]];
//table과 비슷한 구조 (2차원 배열)
// [1,2,3,4],
// [1,2,3,4],
// [1,2,3,4],
// [1,2,3,4]
for (let i = 0; i < mul2_arr.length; i++) {
    for (let j = 0; j < mul2_arr[i].length; j++) {
        const element = mul2_arr[i][j];
        console.log(element);
    } 
    console.log("  ");   
}

//> < (숫자만 비교)
//만약 문자열을 > <  로 비교하면 문자열의 가장 앞의 문자의 문자 코드를 비교한다.
//"abc">"bcd"
//"a".charCodeAt()>"b".charCodeAt();

//123>"345"
//123>345

//"123">"345"
//"1".charCodeAt()> 3.charCodeAt();
console.log("1".charCodeAt());
console.log("21".charCodeAt());

</script>



</body>
</html>